# 静态

## 类和结构体外的静态

- 在类或结构体外部使用静态

这意味着你定义的函数和变量只对他声明所在的 cpp 文件(翻译单元.obj)是"可见"的.

- 在类或结构体内使用静态

此时表示静态变量所在的内存是所有类的实例共享的,静态变量的实例只有一个.

类中的静态函数也一样，静态函数中没有该实例的指针（this）。在类中没有实例会传递给该函数.

除非你真的需要,否则没必要将其设置为全局变量.

我们不能声明两个标识符相同的全局变量.

使用 extern 声明可以将一个变量改为另一个翻译单元的变量的引用.

```cpp
// static.cpp中
int s_var = 5;

// main.cpp
extern int s_var;   //注意这里没有了赋值
int main(){
    std::cout << s_var << std::endl;
}

// 输出5
```

## 类与结构体内的静态

- 静态方法不能访问非静态成员
- 静态方法没有类实例
- 本质上在类中写的每个非静态方法都会获得当前类的实例作为参数.
- 静态成员在变量编译时存储在静态存储区,即定义过程在编译时完成,因此一定要在类外进行定义,但可以不进行初始化.- 静态成员变量是所有实例共享的;但是其只在类中进行了声明,并未定义或初始化(分配内存).类或者类实例就无法访问-静态成员变量，这显然是不对的,所以必须先在类外部定义,也就是分配内存.
- 通过类的实例引用静态成员是没有意义的,在静态函数中引用类的实例成员也是没有意义的.

静态方法和在类外编写函数是一致的.

```cpp
struct Entity
{
    int x;

    static void print()
    {
        cout << x << endl;  // 报错，不能访问到非静态变量x
    }
};
//在类外面写一个print()函数
static void print()
{
    cout << x << endl;  // 报错，x是什么？没被定义。
}
```

使用参数列表可以访问类的实例成员.

```cpp
struct Entity
{
    int x;

    static void print(Entity e)
    {
        cout << e.x << endl;  // 报错，不能访问到非静态变量x
    }
};
```
